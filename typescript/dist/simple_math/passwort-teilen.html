<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Passw√∂rter teilen</title>
    <script>
// @ts-check

window.addEventListener('DOMContentLoaded', () => {
  documentElement('javascriptWarning').style.display = 'none'
})

// COMBINING SHARES //

window.addEventListener('DOMContentLoaded', () => {
  registerListener('fillExampleSharesButton', 'click', () => {
    textAreaElement('shareInput1').value = `{
      "Teil Nummer": 4,
      "a": 2,
      "b": 2,
      "c": [62,256,90,164,90,206,221,134,95,84,215,214,30,151,161,202,209,141,221,49],
      "v": [141,83,12,116,122,74,154,110,44,157,126,188,24,148,237,250,6,110,69,228]
    }`
    textAreaElement('shareInput2').value = `{
      "Teil Nummer": 2,
      "a": 1,
      "b": 2,
      "c": [168,252,203,200,169,12,143,107,187,164,112,98,39,211,44,143,46,199,123,140],
      "v": [1,72,164,129,170,93,107,229,227,83,87,36,15,132,103,225,158,235,110,255]
    }`
    textAreaElement('shareInput3').value = `{
      "Teil Nummer": 5,
      "a": 3,
      "b": 4,
      "c": [36,90,178,6,160,104,6,125,249,249,71,56,70,106,206,89,256,84,88,190],
      "v": [205,251,61,144,193,53,160,223,238,241,214,225,40,24,84,219,165,89,180,227]
    }`
    shareInputChanged()
  })

  registerListener('shareInput1', 'change', () => shareInputChanged())
  registerListener('shareInput2', 'change', () => shareInputChanged())
  registerListener('shareInput3', 'change', () => shareInputChanged())

})

function shareInputChanged() {
  const share1 = shareInput(textAreaElement('shareInput1').value, documentElement('shareInput1Status'))
  const share2 = shareInput(textAreaElement('shareInput2').value, documentElement('shareInput2Status'))
  const share3 = shareInput(textAreaElement('shareInput3').value, documentElement('shareInput3Status'))
  const c = restore(share1, share2, share3, share => share.c)
  const cString = bytesToUtf8(c.filter(n => n < 256))
  const v = restore(share1, share2, share3, share => share.v)
  const vString = bytesToUtf8(v.filter(n => n < 256))
  inputElement('restoredNumbersC').value = `${c}`
  inputElement('restoredNumbersV').value = `${v}`
  if (`${c}` === `${v}`) inputElement('restoredNumbersV').classList.remove('problem')
  else inputElement('restoredNumbersV').classList.add('problem')
  inputElement('restoredStringC').value = cString
  inputElement('restoredStringV').value = vString
  if (cString === vString) inputElement('restoredStringV').classList.remove('problem')
  else inputElement('restoredStringV').classList.add('problem')
}

function restore(share1, share2, share3, accessor) {
  const length =
    Math.max(accessor(share1)?.length ?? 0, accessor(share2)?.length ?? 0, accessor(share3)?.length ?? 0)
  return Array.from({ length: length }).map((_, index) =>
    calculateShare(
      share1.a, share2.a, share3.a,
      share1.b, share2.b, share3.b,
      accessor(share1)[index], accessor(share2)[index], accessor(share3)[index]
    )
  )
}

function shareInput(share, statusSpan) {
  if (share === '') {
    statusSpan.classList.remove('problem')
    statusSpan.textContent = 'Leer'
    return undefined
  }
  try {
    const json = JSON.parse(share)
    if (!Number.isInteger(json.a) || json.a < 1 || json.a > 10) throw 'a'
    if (!Number.isInteger(json.b) || json.b < 1 || json.b > 10) throw 'b'
    if (!Array.isArray(json.c) || json.c.some(n => !Number.isInteger(n) || n < 0 || n > 256)) throw 'c'
    if (!Array.isArray(json.v) || json.v.some(n => !Number.isInteger(n) || n < 0 || n > 256))
      statusSpan.textContent = `Unerwartete Eingabe f√ºr Feld v`
    else
      statusSpan.textContent = `Eingabeformat OK`
    statusSpan.classList.remove('problem')
    return json
  } catch (e) {
    statusSpan.classList.add('problem')
    if (typeof e === "string")
      statusSpan.textContent = `Unerwartete Eingabe f√ºr Feld ${e}`
    else
      statusSpan.textContent = 'Unerwartetes Eingabeformat'
    return undefined
  }
}

/* a1 * p + b1 * q + c1 = s
 * a2 * p + b2 * q + c2 = s
 * a3 * p + b3 * q + c3 = s
 * 
 *     a1*c2*b3 + a3*c1*b2 + c3*a2*b1 - a2*c1*b3 - c2*a3*b1 - a1*c3*b2
 * s = ---------------------------------------------------------------
 *              a1*b3 + a3*b2 + a2*b1 - a2*b3 - a3*b1 - a1*b2
 */
function calculateShare(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
  if ([a1, a2, a3, b1, b2, b3, c1, c2, c3].some(n =>
    !Number.isInteger(n) || n < 0 || n > 256
  )) return NaN
  const dividend = mod257(a1*c2*b3 + a3*c1*b2 + c3*a2*b1 - a2*c1*b3 - c2*a3*b1 - a1*c3*b2)
  const divisor = mod257(a1*b3 + a3*b2 + a2*b1 - a2*b3 - a3*b1 - a1*b2)
  return div257(dividend, divisor)
}

function div257(a, b) {
  if (b === 0) return NaN
  let counter = 0
  while (a % b !== 0 && counter++ < 257) a += 257
  return a % b === 0 ? a / b : NaN
}

// CREATING SHARES //

window.addEventListener('DOMContentLoaded', () => {
  registerListener('createSharesButton', 'click', () => createShares())
  registerListener('secretInput', 'change', () => documentElement('shareInfoDiv').hidden = true)
})

function createShares() {
  const secretBytes = utf8ToUint8(inputElement('secretInput').value)
  const padToLength = parseInt(inputElement('padToLengthInput').value)
  const numberOfShares = parseInt(inputElement('numberOfSharesInput').value)
  const maxFactorAB = Math.ceil(Math.sqrt(numberOfShares))
  const paddingLength = Math.max(padToLength - secretBytes.length, 0)
  const secretPadded = [...secretBytes, ...new Array(paddingLength).fill(256)]
  const length = secretPadded.length
  const p1 = secretPadded.map(() => Math.floor(Math.random() * 257))
  const q1 = secretPadded.map(() => Math.floor(Math.random() * 257))
  const p2 = secretPadded.map(() => Math.floor(Math.random() * 257))
  const q2 = secretPadded.map(() => Math.floor(Math.random() * 257))
  const shares = [
    {"a": 1, "b": 2},   //   1/2
    {"a": 2, "b": 1},   //   2/1
    {"a": 2, "b": 4},   //   2/4
    {"a": 1, "b": 5},   //   1/5
    {"a": 5, "b": 2},   //   5/2
    {"a": 6, "b": 3},   //   6/3
    {"a": 3, "b": 7},   //   3/7
    {"a": 4, "b": 7},   //   4/7
    {"a": 7, "b": 5},   //   7/5
    {"a": 3, "b": 8},   //   3/8
    {"a": 7, "b": 8},   //   7/8
    {"a": 4, "b": 9},   //   4/9
    {"a": 6, "b": 9},   //   6/9
    {"a": 9, "b": 1},   //   9/1
    {"a": 9, "b": 3},   //   9/3
  ];
  shares.length = numberOfShares;
  shares.forEach(ab => {
    ab.c = secretPadded.map((s, index) =>
      calculateC(ab.a, ab.b, p1[index], q1[index], s)
    )
    ab.validation = secretPadded.map((s, index) =>
      calculateC(ab.a, ab.b, p2[index], q2[index], s)
    )
  })
  documentElement('sharesSpan').innerHTML = shareText(shares)
  documentElement('sharesDescriptionSpan').innerText = textAreaElement('sharesDescriptionInput').value.replace(/\r?\n/g, ' ')
  documentElement('numberOfSharesSpan').innerText = `${numberOfShares}`
  const date = new Date()
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  const localizedDate = document.documentElement.lang === 'de' ? `${day}.${month}.${year}` : `${year}-${month}-${day}`
  documentElement('createdDateSpan').innerText = localizedDate
  documentElement('secretNumbersSpan').innerHTML = `s: ${secretPadded}`
  documentElement('pqValuesSpan').innerHTML = `p: ${p1}<br />q: ${q1}`
  documentElement('pqValidationValuesSpan').innerHTML = `p: ${p2}<br />q: ${q2}`
  documentElement('shareInfoDiv').hidden = false
}

function factorAB(index, maxFactorAB) {
  return {a: Math.floor(index/maxFactorAB) + 1, b: index%maxFactorAB + 1}
}

// calculate c for a*p + b*q + c = s
function calculateC(a, b, p, q, s) {
  return mod257(s - a*p - b*q)
}

// GENERAL MATH FUNCTIONS //

// calculate the always positive modulo
function mod257(number) {
  return (number % 257 + 257) % 257
}

// DOCUMENT UTILITIES //

function shareText(shares) {
  const localizedKey = document.documentElement.lang === 'de' ? 'Teil Nummer' : 'share number'
  return shares.map((share, index) => {
    return cleanMultiline(`
      |{
      |  "${localizedKey}": ${index + 1},
      |  "a": ${share.a},
      |  "b": ${share.b},
      |  "c": ${JSON.stringify(share.c)},
      |  "v": ${JSON.stringify(share.validation)}
      |}
    `)
  })
  .join('<br /><br />')
}

function cleanMultiline(text) {
  return text
    .split(/\r?\n/)
    .filter((line) => line.trim() !== '')
    .map((line) => line.replace(/^ +\|/, ''))
    .join('<br />')
}

function documentElement(elementIdString) {
  const maybeElement = document.getElementById(elementIdString)
  if (maybeElement !== null) return maybeElement
  throw error('Null check in script failed')
}

function inputElement(elementIdString) {
  const maybeInput = documentElement(elementIdString)
  if (maybeInput instanceof HTMLInputElement) return maybeInput
  throw error('Type check in script failed')
}

function textAreaElement(elementIdString) {
  const maybeInput = documentElement(elementIdString)
  if (maybeInput instanceof HTMLTextAreaElement) return maybeInput
  throw error('Type check in script failed')
}

function registerListener(elementIdString, eventTypeString, eventListener) {
  documentElement(elementIdString).addEventListener(eventTypeString, eventListener)
}

function error(messageString) {
  alert(`Oh bother: ${messageString}.`)
  return new Error(messageString)
}

function utf8ToUint8(text) {
  return new TextEncoder().encode(text)
}

function bytesToUtf8(bytes) {
  return new TextDecoder().decode(new Uint8Array(bytes))
}

    </script>
    <style>

/* TODO review & remove orphans */
body {
  max-width: 600px;
  font-size: 115%;
  font-family: system-ui, sans-serif, serif;
}
.problem {
  border-color: red;
  color: red;
}
.scrollable {
  width: auto;
  overflow-x: auto;
  border: 1px solid #cccccc;
  padding: 10px;
}
.textinput {
  background-color: #fbfbfb;
  border-color: #cccccc;
  border-left: none;
  border-right: none;
  padding-left: 0%;
  padding-right: 0%;
  width: 100%;
}
p {
  line-height: 140%;
}
ol {
  margin-left: -1.2em;
}
ul {
  margin-left: -1em;
}

    </style>
  </head>

  <body>
    <main>
      <h1>Passw√∂rter teilen und wiederherstellen</h1>
      <p><a href="share-simple3.html">This page in English (üî¥TODOüî¥)</a></p>
      <p id="javascriptWarning" class="problem">
        Ups! Diese Seite braucht JavaScript, und es scheint, dass JavaScript nicht aktiviert ist. Vielleicht m√∂chtest Du einen anderen Browser verwenden? Oder es liegt daran, dass irgendwie der JavaScript Teil abhanden gekommen ist.
      </p>
      <p>
        <b>Wenn Du von jemandem f√ºr Notf√§lle einen verschl√ºsselten Teil eines Passworts bekommen hast,</b> dann hat diese Person hoffentlich weitere Teile bei weiteren Personen oder an sinnvollen Orten hinterlegt. Sobald Du drei unterschiedliche Teile hast, kannst Du auf dieser Seite das Passwort rekonstruieren - nat√ºrlich nur, wenn es mit dem auf dieser Seite beschriebenen Verfahren verschl√ºsselt und geteilt wurde.
      </p>
      <p>
        <b>Wenn Du ein Passwort hast, auf das im Notfall jemand zugreifen k√∂nnen soll auch wenn Du selbst nicht erreichbar bist,</b> dann kannst Du auf dieser Seite das Passwort in mehrere Teile verschl√ºsselt aufteilen. Diese Teile kannst Du z.&#x202F;B. an Freunde weitergeben. Nur wenn mindestens drei Teile zusammengef√ºhrt werden, kann das urspr√ºngliche Passwort rekonstruiert werden.
      </p>
      <p>
        <b>Bei dem Verfahren wird nur einfache Mathematik verwendet,</b> so dass man zur Not die Berechnungen sogar mit Stift und Papier durchf√ºhren kann. Details und weitere Informationen findest Du im Abschnitt zur theoretischen Grundlage.
      </p>
      <nav aria-label="Inhaltsverzeichnis">
        <h2 id="tocNav">Inhaltsverzeichnis</h2>
        <ul>
          <li><a href="#combineSharesNav">Ein Passwort aus drei Teilen wiederherstellen</a></li>
          <li><a href="#createSharesNav">Ein Passwort verschl√ºsselt aufteilen</a></li>
          <li><a href="#theoryNav">Die Theorie hinter dem Ganzen</a></li>
        </ul>
      </nav>
      <hr />
      <h2 id="combineSharesNav">Ein Passwort aus drei Teilen wiederherstellen</h2>
      <a href="#tocNav">Hier geht es nach oben zum Inhaltsverzeichnis.</a>
      <p>
        <b>Wenn Du von jemandem f√ºr Notf√§lle einen verschl√ºsselten Teil eines Passworts bekommen hast,</b> dann hat derjenige hoffentlich weitere Teile bei weiteren Personen oder an sinnvollen Orten hinterlegt. Wenn Du drei unterschiedliche Teile hast, kannst Du hier das Passwort rekonstruieren - nat√ºrlich nur, wenn es mit dem auf dieser Seite beschriebenen Verfahren verschl√ºsselt und geteilt wurde.
      </p>
      <p>
        <button id="fillExampleSharesButton" type="button" aria-label="Beispielwerte eintragen">Wenn Du hier klickst, werden Beispielwerte eingetragen.</button>
      </p>
      <div>
        <label for="shareInput1">Teil 1</label> - Status: <span id="shareInput1Status">Leer</span>
        <textarea
          id="shareInput1"
          class="textinput"
          rows="8"
          wrap="off"
          placeholder="Hier kannst Du Teil 1 des verschl√ºsselt geteilten Passworts eingeben."
        ></textarea>
        <label for="shareInput2">Teil 2</label> - Status: <span id="shareInput2Status">Leer</span>
        <textarea
          id="shareInput2"
          class="textinput"
          rows="8"
          wrap="off"
          placeholder="Hier kannst Du Teil 2 des verschl√ºsselt geteilten Passworts eingeben."
        ></textarea>
        <label for="shareInput3">Teil 3</label> - Status: <span id="shareInput3Status">Leer</span>
        <textarea
          id="shareInput3"
          class="textinput"
          rows="8"
          wrap="off"
          placeholder="Hier kannst Du Teil 3 des verschl√ºsselt geteilten Passworts eingeben."
        ></textarea>
      </div>
      <div>
        <br>
        <label for="restoredNumbersC">Wiederhergestelltes Passwort als Zahlen:</label><br />
        <input id="restoredNumbersC" class="textinput" type="text" value="" size="100" readonly />
        <label for="restoredNumbersV">Validierung der Wiederherstellung als Zahlen:</label><br />
        <input id="restoredNumbersV" class="textinput" type="text" value="" size="100" readonly />
        <br><br>
        <label for="restoredStringC">Wiederhergestelltes Passwort als String:</label><br />
        <input id="restoredStringC" class="textinput" type="text" value="" size="100" readonly />
        <label for="restoredStringV">Validierung der Wiederherstellung als String:</label><br />
        <input id="restoredStringV" class="textinput" type="text" value="" size="100" readonly />
      </div>
      <p>
        <b>Wenn sich Passwort-Daten und Validierungs-Daten unterscheiden, ist das angezeigte wiederhergestellte Passwort m√∂glicherweise nicht korrekt.</b> M√∂gliche Gr√ºnde f√ºr die Unterschiede sind, dass Teile kombiniert wurden, die nicht zueinander geh√∂ren, oder dass die Daten in den Teilen nicht komplett richtig vorliegen.
      </p>
      <hr />
      <h2 id="createSharesNav">Ein Passwort verschl√ºsselt aufteilen</h2>
      <a href="#tocNav">Hier geht es nach oben zum Inhaltsverzeichnis.</a>
      <p>
        <b>Wenn Du ein Passwort hast, auf das im Notfall jemand zugreifen k√∂nnen soll auch wenn Du nicht verf√ºgbar bist,</b> dann kannst Du hier das Passwort in mehrere Teile verschl√ºsselt aufteilen. Diese Teile kannst Du z.&#x202F;B. an Freunde weitergeben. Nur wenn mindestens drei Teile zusammengef√ºhrt werden, kann das urspr√ºngliche Passwort rekonstruiert werden.
      </p>
      <div>
        <label for="secretInput">Passwort:</label>
        <input id="secretInput" class="textinput" type="text" value="¬°secret!" />
        <br><br>
        <label for="padToLengthInput">Passwort auf Mindestl√§nge erweitern (nicht erweitern: 0, Maximum: 64):</label>
        <input id="padToLengthInput" class="textinput" type="number" min="0" max="64" step="1" value="20" />
        <br><br>
        <label for="numberOfSharesInput">Anzahl der zu erzeugenden Teile (Minimum: 3, Maximum: 15):</label>
        <input id="numberOfSharesInput" class="textinput" type="number" min="3" max="15" step="1" value="8" />
        <br><br>
        <label for="sharesDescriptionInput">Optionale Beschreibung der Teile:</label>
        <textarea
          id="sharesDescriptionInput"
          class="textinput"
          rows="3"
          placeholder="Hier kannst Du die Beschreibung eingeben."
        ></textarea>
        Beispielbeschreibung:<br>
        <i>Es handelt sich um Marias Benutzerdaten von 2023 bei ihrer Hausbank, geteilt mit ihren Angeh√∂rigen f√ºr Notf√§lle.</i>
      </div>
      <p><button id="createSharesButton" type="button">Klicke hier um die Teile zu erzeugen</button> und scrolle dann nach unten.</p>
      <p>
        Wenn Du Teile an andere weitergibst, dann gib' am besten eine Kopie dieser Seite mit. Sie ist so gestaltet, dass man sie einfach als Datei abspeichern und wieder √∂ffnen kann und sie komplett ohne Internetverbindung funktioniert.
      </p>

      <div id="shareInfoDiv" hidden>
        <p>
          Unten findest Du die verschl√ºsselten Teile deines Passworts. Danach folgt ein Vorschlag, wie Du die Teile an andere Personen weitergeben kannst, damit diese auch in zehn Jahren noch wissen, was sie da haben.
        </p>
        <hr />
        <pre class="scrollable"><span id="sharesSpan">DYNAMISCHER TEXT: Die verschl√ºsselten Teile</span>
          <br>==> ==>  Eventuell musst Du scrollen  ==> ==></pre>
        <hr />
        <p>
          Im Folgenden findest Du ein Beispiel daf√ºr, wie Du die Teile weitergeben k√∂nntest &ndash; passe es nach Bedarf an.
        </p>
        <p>
          <i>
            Dies ist ein verschl√ºsselter Teil eines Passworts.
            <span id="sharesDescriptionSpan">DYNAMISCHER TEXT: Beschreibung</span>
            Bitte bewahre ihn an einem sicheren Ort auf, z.&#x202F;B. in deinem Passwort-Programm. Du hast diesen Teil erhalten, damit Du im Notfall &ndash; zusammen mit zwei weiteren Personen, die ebenfalls Teile erhalten haben &ndash; das Passwort rekonstruieren und alles weitere Notwendige veranlassen kannst. Dies ist einer von
            <span id="numberOfSharesSpan">DYNAMISCHER TEXT: Anzahl</span> Teilen, erstellt am
            <span id="createdDateSpan">DYNAMISCHER TEXT: Datum</span>. F√ºr die tats√§chliche Rekonstruktion wird dieser Text nicht ben√∂tigt, nur die folgenden Daten:
          </i>
        </p>
        <p>
          <b><i>[Ersetze diesen Absatz mit dem Teil, den Du weitergeben m√∂chtest.]</i></b>
        </p>
        <p>
          <i>
            Dieser Teil wurde mithilfe der Webseite <a href="https://gdiet.github.io/secret-sharing/simple_math/passwort-teilen.html">https://gdiet.github.io/secret-sharing/simple_math/passwort-teilen.html</a> erstellt, von der Dir eine Kopie zusammen mit diesem Text √ºbergeben wurde. Diese Webseite kann ohne Internetverbindung genutzt werden und hat auch eine Funktion zur Wiederherstellung des Passworts aus mehreren Teilen.
          </i>
        </p>
        <p>
          <i>
            F√ºr den Fall, dass Du die Webseite nicht verwenden kannst oder die Funktion der Webseite manuell verifizieren m√∂chtest, ist hier eine Beschreibung des Verfahrens zur Wiederherstellung des Passworts aus den drei Teilen:<br>
            * Gegeben sind drei Teile, jeweils mit den Feldern a, b, c und v.<br>
            * c und v sind dabei jeweils eine Liste von Zahlen.<br>
            * Alle c-Werte werden einzeln nacheinander verwendet.<br>
            Die drei a- und b-Werte sowie den jeweils ersten c-Wert nennen wir im folgenden a1, a2, a3, b1, b2, b3, c1, c2, c3. F√ºr jede Position in der c-Liste ist das folgende Verfahren entsprechend auszuf√ºhren:
          </i>
        </p>
        <p>
          <i>
            Berechne die Werte m und n.
            <pre>
m = a1*b3*c2 + a2*b1*c3 + a3*b2*c1 - a1*b2*c3 - a2*b3*c1 - a3*b1*c2
n = a1*b3    + a2*b1    + a3*b2    - a1*b2    - a2*b3    - a3*b1   </pre>
          </i>
        </p>
        <p>
          <i>
            Im folgenden brauchen wir die Rechenoperationen Modulo, die den Rest einer ganzzahligen Division berechnet. Wenn eine Zahl x durch eine Zahl y geteilt wird, ergibt der Ausdruck x mod y den Rest dieser Division. Zum Beispiel ist 5 mod 3 = 2, da 5 geteilt durch 3 einen Rest von 2 l√§sst. Vorzeichen behandelst Du dabei so:<br>
            <pre>
-17 mod -7 = +17 mod +7 =                = 3
-17 mod +7 = +17 mod -7 = 7 - (17 mod 7) = 4</pre>
            Der Modulo ist also nie negativ.
          </i>
        </p>
        <p>
          <i>
            Au√üerdem brauchen wir "div257", die Division im Zahlenraum Modulo 257. x div257 y berechnest Du so: Du pr√ºfst, ob x ohne Rest durch y teilbar ist. Ist es nicht ohne Rest teilbar, dann addiere 257 zu x und pr√ºfe erneut. Wiederhole diesen Vorgang, bis Du eine Zahl erh√§ltst, die ohne Rest durch y teilbar ist. Das Ergebnis dieser Division ist das Ergebnis von "div257". Beispiele:
            <pre>
12 div257 4 = 3  ... 12 / 4 = 3 ist ohne Rest teilbar
15 div257 4      ... 15 / 4 ist nicht ohne Rest teilbar
15 div257 4      ... 15 + 257 = 272
15 div257 4 = 68 ... 272 / 4 = 68 ist ohne Rest teilbar</pre>
          </i>
        </p>
        <p>
          <i>
            Aus m und n berechnet sich die Zahl des Passworts an der aktuellen Position:
            <pre>s = (m mod 257) div257 (n mod 257)</pre>
            s ist eine Zahl zwischen 0 und 256. S√§mtliche Zahlen s = 256 werden ignoriert, die √ºbrigen Zahlen werden als UTF-8 Zeichenkette interpretiert. H√§ufig verwendete UTF-8 Zeichen sind:
            <pre>      32: Leerzeichen
48 -  57: Ziffern 0-9
65 -  90: Gro√übuchstaben A-Z
97 - 122: Kleinbuchstaben a-z</pre>
          </i>
        </p>
        <p>
          <i>
            Wenn Du aus den c-Werten das Passwort rekonstruiert hast, dann kannst Du es mit den v-Werten validieren. Dazu berechnest Du f√ºr jeden v-Wert die Zahl s wie oben beschrieben und vergleichst sie mit dem entsprechenden c-Wert. Wenn sich Passwort-Daten und Validierungs-Daten unterscheiden, ist das wiederhergestellte Passwort m√∂glicherweise nicht korrekt. M√∂gliche Gr√ºnde f√ºr die Unterschiede sind, dass Teile kombiniert wurden, die nicht zueinander geh√∂ren, oder dass die Daten in den Teilen nicht komplett richtig vorliegen.
          </i>
        </p>
        <p>
          (Ende des Beispiels f√ºr einen Text, wie Du die Teile an andere weitergeben kannst.)
        </p>
        <h3>Wenn dich die Mathematik der Berechnung interessiert...</h3>
        <p>
          ... findest Du hier die UTF-8 Zahlenwerte (s-Werte), die das Passwort darstellen:
          <pre class="scrollable"><span id="secretNumbersSpan">DYNAMISCHER TEXT: Passwort als Zahlen (UTF-8)</span>
          <br/>==> ==>  Eventuell musst Du scrollen  ==> ==></pre>
          Folgendes sind die p- und q-Werte (siehe <a href="#theoryNav">Die Theorie hinter dem Ganzen</a>), die f√ºr die Berechnung der c-Werte verwendet wurden:
          <pre class="scrollable"><span id="pqValuesSpan">DYNAMISCHER TEXT: Werte von p und q</span>
          <br/>==> ==>  Eventuell musst Du scrollen  ==> ==></pre>
          Und folgendes sind die p- und q-Werte, die f√ºr die Berechnung der v-Werte f√ºr die Validierung verwendet wurden:
          <pre class="scrollable"><span id="pqValidationValuesSpan">DYNAMISCHER TEXT: Werte von p und q (Validierung)
          <br/>==> ==>  Eventuell musst Du scrollen  ==> ==></pre>
          <b>Wichtig:</b> Die s-, p- und q-Werte werden <b>nicht</b> ben√∂tigt, wenn Du das Passwort verschl√ºsselt teilst. Gib sie <b>auf keinen Fall</b> an andere Personen weiter. Es ist <b>nicht</b> n√∂tig sie zu speichern.
        </p>
      </div>
    </main>
    <hr />
    <h2 id="theoryNav">Die Theorie hinter dem Ganzen</h2>
    <a href="#tocNav">Hier geht es nach oben zum Inhaltsverzeichnis.</a>
    <p>
      Wenn Du ein Passwort hast, auf das im Notfall jemand zugreifen k√∂nnen soll auch wenn Du selbst nicht erreichbar bist, dann gibt es M√∂glichkeiten, das Passwort in mehrere Teile verschl√ºsselt aufzuteilen. Diese Teile kannst Du z.&#x202F;B. an Freunde weitergeben. Nur wenn mindestens eine bestimmte Anzahl von Teilen zusammengef√ºhrt werden, kann das urspr√ºngliche Passwort rekonstruiert werden.
    </p>
    <p>
      Auf dieser Seite geht es um ein Verfahren und die Theorie dahinter, wenn zur Rekonstruktion <b>drei</b> Teile ben√∂tigt werden. Es gibt auch Verfahren, bei denen nur <b>zwei</b> Teile ben√∂tigt werden, und es gibt Verfahren, bei denen man die ben√∂tigte Anzahl der Teile <b>frei w√§hlen</b> kann. Diese Verfahren sind aber nicht Thema dieser Seite. Ein bekannter Ansatz f√ºr "beliebige Anzahl" ist √ºbrigens Shamir's Secret Sharing - weitere Informationen und eine Implementierung findest Du zum Beispiel hier: <a href="https://gdiet.github.io/secret-sharing/share-compact.html">https://gdiet.github.io/secret-sharing/share-compact.html</a>
    </p>
    <h3>Ein Gleichungsystem mit drei Unbekannten</h3>
    <p>
      Nehmen wir zun√§chst an, dass es nicht um ein Passwort geht, sondern um eine geheime Zahl <i>s</i>. Wenn ich ein Gleichungssystem mit drei Unbekannten habe, und davon ist eine <i>s</i>, dann kann ich ohne <i>p</i> und <i>q</i> zu kennen das Gleichungssystem nach <i>s</i> aufl√∂sen, wenn ich drei voneinander linear unabh√§ngige Gleichungen habe.
    </p>
    <p>
      Wenn <i>p</i> und <i>q</i> zwei Zufallszahlen sind, und die jeweils drei <i>a</i>, <i>b</i> und <i>c</i> Werte bekannt sind, dann kann man das folgende Gleichungssystem nach <i>s</i> aufl√∂sen:
    </p>
    <p>
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub><mi>a</mi><mn>1</mn></msub>
        <mo>‚àó</mo><mi>p</mi><mo>+</mo>
        <msub><mi>b</mi><mn>1</mn></msub>
        <mo>‚àó</mo><mi>q</mi><mo>+</mo>
        <msub><mi>c</mi><mn>1</mn></msub>
        <mo>=</mo><mi>s</mi>
      </math>
      <br>
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub><mi>a</mi><mn>2</mn></msub>
        <mo>‚àó</mo><mi>p</mi><mo>+</mo>
        <msub><mi>b</mi><mn>2</mn></msub>
        <mo>‚àó</mo><mi>q</mi><mo>+</mo>
        <msub><mi>c</mi><mn>2</mn></msub>
        <mo>=</mo><mi>s</mi>
      </math>
      <br>
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <msub><mi>a</mi><mn>3</mn></msub>
        <mo>‚àó</mo><mi>p</mi><mo>+</mo>
        <msub><mi>b</mi><mn>3</mn></msub>
        <mo>‚àó</mo><mi>q</mi><mo>+</mo>
        <msub><mi>c</mi><mn>3</mn></msub>
        <mo>=</mo><mi>s</mi>
      </math>
    </p>
    <p>
      Mit etwas M√ºhe oder einem Mathe-Programm erh√§ltst Du folgende L√∂sung f√ºr <i>s</i>:
    </p>
    <p>
      <!--
      https://tools.simonwillison.net/markdown-math
      $$s = \frac{a_1b_3c_2 + a_2b_1c_3 + a_3b_2c_1 - a_1b_2c_3 - a_2b_3c_1 - a_3b_1c_2}{a_1b_3 + a_2b_1 + a_3b_2 - a_1b_2 - a_2b_3 - a_3b_1}$$
      -->
      <math xmlns="http://www.w3.org/1998/Math/MathML" style="font-size: 130%;"><semantics><mrow><mi>s</mi><mo>=</mo><mfrac><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>3</mn></msub><msub><mi>c</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><msub><mi>c</mi><mn>3</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>‚àí</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>c</mi><mn>3</mn></msub><mo>‚àí</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>3</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>‚àí</mo><msub><mi>a</mi><mn>3</mn></msub><msub><mi>b</mi><mn>1</mn></msub><msub><mi>c</mi><mn>2</mn></msub></mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>3</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>‚àí</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>‚àí</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>3</mn></msub><mo>‚àí</mo><msub><mi>a</mi><mn>3</mn></msub><msub><mi>b</mi><mn>1</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">s = \frac{a_1b_3c_2 + a_2b_1c_3 + a_3b_2c_1 - a_1b_2c_3 - a_2b_3c_1 - a_3b_1c_2}{a_1b_3 + a_2b_1 + a_3b_2 - a_1b_2 - a_2b_3 - a_3b_1}</annotation></semantics></math>      
    </p>
    <p>
      Jetzt kommt die Bedingung der "drei voneinander linear unabh√§ngige Gleichungen" ins Spiel: Wenn zum Beispiel <i>a1</i> = <i>a2</i> = <i>a3</i> ist, dann ist der Nenner 0, und bei der Division haben wir ein Problem. Nur wenn der Nenner ungleich 0 ist, k√∂nnen wir <i>s</i> berechnen.
    </p>
    <p>
      Folgende f√ºnfzehn <i>a</i>/<i>b</i>-Werte haben die Eigenschaft, dass jede beliebige Kombination von drei <i>a</i>/<i>b</i>-Werten voneinander linear unabh√§ngig ist:
      <pre>1/2 2/1 2/4 1/5 5/2 6/3 3/7 4/7 7/5 3/8 7/8 4/9 6/9 9/1 9/3</pre>
      Diese Wertepaare habe ich mittels eines Programms ermittelt, das zuf√§llige Kombinationen auf ihre Unabh√§ngigkeit pr√ºft:
      <pre>val tuples = for {i <- 1 to 9; j <- 1 to 9} yield (i, j)
while (true)
  val selection = scala.util.Random.shuffle(tuples).take(15)
  if selection.combinations(3).forall {
    case Seq((a1, b1), (a2, b2), (a3, b3)) =>
      a1*b3 + a2*b1 + a3*b2 - a1*b2 - a2*b3 - a3*b1 != 0
  } then println(selection)</pre>
    Weitere Wertepaare lassen sich ermitteln, interessieren hier aber erst mal nicht.
    </p>
    <p>
      Das sieht soweit doch schon mal gut aus. Wir k√∂nnen bis zu 15 Personen je einen Satz voneinander unabh√§ngiger <i>a</i> / <i>b</i> / <i>c</i> Werte geben, so dass es stets drei Personen braucht, um <i>s</i> zu rekonstruieren. Oder nicht?
    </p>
    <h3>Zus√§tzliches Wissen</h3>
    <p>
      Braucht es wirklich drei Personen, um Informationen √ºber die geheime Zahl <i>s</i> zu bekommen? In der echten Welt ist das leider nicht immer der Fall. Das liegt daran, dass die Personen m√∂glicherweise zus√§tzliches Wissen √ºber <i>p</i>, <i>q</i> und <i>s</i> verwenden k√∂nnen. Wenn beispielsweise bekannt ist, dass <i>p</i>, <i>q</i> und <i>s</i> Bytes sind, also Zahlen im Bereich <i>[0..255]</i>, und wenn ein <i>c</i>-Wert <i>255</i> ist, dann m√ºssen die zugeh√∂rigen <i>p</i>/<i>q</i> Werte <i>0</i> sein und <i>s&nbsp;=&nbsp;c</i>. Oder wenn bekannt ist, dass nur ganze Zahlen in der Berechnung verwendet werden, und wenn bei einer Person <i>a</i>, <i>b</i> und <i>c</i> gerade sind, dann wei√ü diese Person, dass auch <i>s</i> gerade ist. Diese und √§hnliche √úberlegungen k√∂nnen verwendet werden, um aus nur einer oder zwei Gleichungen zumindest einige Erkenntnisse √ºber den geheimen Wert <i>s</i> zu gewinnen.
    </p>
    <h3>Der Zahlenraum <i>mod&nbsp;257</i></h3>
    <p>
      Deshalb wenden wir einen Trick an: Wir f√ºhren alle Berechnungen <i>modulo&nbsp;257</i> - oder kurz: <i>mod&nbsp;257</i> - durch, was uns den Zahlenbereich <i>[0..256]</i> zum Arbeiten gibt - ein praktischer Raum, wenn wir mit Bytes arbeiten wollen.
    </p>
    <p>
      Anstelle von <i>257</i> k√∂nnte man auch eine beliebige andere Primzahl verwenden. Mit <i>mod&nbsp;101</i> h√§tten wir zum Beispiel den Zahlenbereich <i>[0..100]</i>, was je nach Anwendung auch sehr praktisch sein kann...
    </p>
    <p>
      F√ºr negative Zahlen bei Modulo verwenden wir hier die Regeln, dass
      <pre>-x mod -y = +x mod +y
-x mod +y = +x mod -y = y - (x mod y)</pre>
      ist, so dass der Modulo nie negativ ist. Beispiel:
      <pre>-17 mod -7 = +17 mod +7 = 3
-17 mod +7 = +17 mod -7 = 7 - (17 mod 7) = 4</pre>
    </p>
    <p>
      Wenn jetzt jemand zum Beispiel die Werte <i>a</i> = 2, <i>b</i> = 2, <i>c</i> = 2 kennt, dann hat er √ºber <i>s</i> trotzdem keine zus√§tzlichen Informationen, weil
      <pre>s = (a*p + b*q + c) mod 257</pre>
      je nach dem Wert von <i>p</i> und <i>q</i> jeden Wert zwischen <i>0</i> und <i>256</i> haben kann.
    </p>
    <h3>Rechnen im Zahlenraum <i>mod&nbsp;257</i></h3>
    <p>
      <pre>Addition      : a + b im Zahlenraum mod 257 = (a + b) mod 257
Subtraktion   : a - b im Zahlenraum mod 257 = (a - b) mod 257
Multiplikation: a * b im Zahlenraum mod 257 = (a * b) mod 257
Division      : a / b im Zahlenraum mod 257 = ... ?</pre>
      Die Division ist etwas aufw√§ndiger: Es ist die Inverse der Multiplikation, also "finde die Zahl <i>c</i>, f√ºr die gilt: <i>(b&nbsp;*&nbsp;c)&nbsp;mod&nbsp;257&nbsp;=&nbsp;a</i>". Du berechnest <i>c</i> am einfachsten so: Pr√ºfe, ob <i>a</i> ohne Rest durch <i>b</i> teilbar ist. Ist es nicht ohne Rest teilbar, dann addiere <i>257</i> zu <i>a</i> und pr√ºfe erneut. Wiederhole diesen Vorgang, bis Du eine Zahl erh√§ltst, die ohne Rest durch <i>b</i> teilbar ist. Das Ergebnis dieser Division ist die gesuchte Zahl <i>c</i>.<br>
      F√ºr negative Zahlen gilt dabei:
      <pre>-a / -b = +a / +b                      | im Zahlenraum mod 257
-a / +b = +a / -b = 257 - ( +a / +b )  | im Zahlenraum mod 257</pre>
    </p>
    <h3>Passw√∂rter teilen</h3>
    <p>
      Richtig, das wollen wir ja eigentlich. Mit dem obigen Handwerkszeug geht das so:
    </p>
    <ol>
      <li>Passwort in Zahlen umwandeln: Ermittle den UTF-8 Code des Passworts. Du erh√§ltst eine Sequenz von Zahlen <i>s</i> zwischen <i>0</i> und <i>255</i>.</li>
      <li>Passwort auf Mindestl√§nge erweitern: Falls Du die L√§nge des Passworts verheimlichen willst, f√ºge an beliebiger Stelle der Sequenz, zum Beispiel am Schluss, so oft Du m√∂chtest <i>256</i> in die Sequenz ein.</li>
      <li>W√§hle f√ºr jede Zahl <i>s</i> aus der Sequenz zwei neue Zufallszahlen <i>p</i> und <i>q</i> aus dem Bereich <i>[0..256]</i>.</li>
      <li>Berechne f√ºr jeden Teil, den Du erstellen willst, f√ºr jede Zahl <i>s</i> der Sequenz die Zahl <i>c</i>. Rechne dabei im <i>mod 257</i> Raum und verwende die oben genannten <i>a</i>/<i>b</i>-Paare.</li>
    </ol>
    <p>
      Wenn Du zum Beispiel folgende Werte hast
      <pre>a = 4, b = 7, p = 23, q = 218, s = 65</pre>
      dann berechne
      <pre>a * p + b * q + c = s     | mod 257
c = s - a * p - b * q     | mod 257
c = (65 - 4 * 23 - 7 * 218) mod 257
c = (-1553) mod 257
c = 257 - (1553 mod 257)
c = 257 - 11
c = 246</pre>
    </p>
    <ol>
      <li value="5">Damit man sp√§ter das rekonstruierte Passwort validieren kann, wiederhole das Verfahren mit neuen Zufallszahlen <i>p</i> und <i>q</i> und erstelle dabei die <i>v</i>-Werte.</li>
      <li>Gib als Teil die Werte <i>a</i> und <i>b</i> sowie die Liste der <i>c</i>- und <i>v</i>-Werte weiter. Der Teil kann dann so aussehen:</li>
    </ol>
    <p><pre>{
  "a": 4,
  "b": 7,
  "c": [236,6,124,109,87],
  "v": [125,177,78,85,40]
}</pre></p>
    <h3>Passw√∂rter wiederherstellen</h3>
    <ol>
      <li>Du hast drei Teile, jeweils mit <i>a</i> und <i>b</i> sowie die Liste der <i>c</i>- und <i>v</i>-Werte.</li>
      <li>Berechne aus diesen Zahlen die zwei Listen der <i>s</i>-Werte - die erste Liste aus den <i>c</i>-Werten, die zweite aus den <i>v</i>-Werten. Verwende die Formel f√ºr <i>s</i>, die wir oben aus dem Gleichungssystem mit drei Gleichungen hergeleitet haben, und rechne dabei im <i>mod 257</i> Zahlenraum.</li>
      <li>Vergleiche die zwei Listen von <i>s</i>-Werten. Wenn sie sich unterscheiden, ist das wiederhergestellte Passwort m√∂glicherweise nicht korrekt. M√∂gliche Gr√ºnde f√ºr die Unterschiede sind neben Rechenfehlern, dass Teile kombiniert wurden, die nicht zueinander geh√∂ren, oder dass die Daten in den Teilen nicht komplett richtig vorliegen.</li>
      <li>Entferne alle Zahlen <i>256</i> aus der Liste.</li>
      <li>Interpretiere die resultierende Liste von Bytes als UTF-8 Zeichenkette.</li>
    </ol>
  </body>
</html>
